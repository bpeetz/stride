// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: require_trailing_commas
// ignore_for_file: always_use_package_imports
// ignore_for_file: directives_ordering
// ignore_for_file: sort_unnamed_constructors_first
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: avoid_dynamic_calls
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: prefer_final_locals
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: inference_failure_on_instance_creation
// ignore_for_file: prefer_single_quotes
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: noop_primitive_operations
// ignore_for_file: prefer_const_constructors
// ignore_for_file: prefer_is_empty
// ignore_for_file: unnecessary_parenthesis

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';
import 'task/annotation.dart';

class Task {
  final UuidValue uuid;
  final TaskStatus status;
  final String description;
  final DateTime? modified;
  final DateTime? due;
  final int? project;
  final Uint32List tags;
  final List<Annotation> annotations;
  final int? priority;
  final DateTime? wait;
  final DateTime? end;
  final List<UuidValue> depends;
  final Map<String, String> uda;

  const Task.raw({
    required this.uuid,
    required this.status,
    required this.description,
    this.modified,
    this.due,
    this.project,
    required this.tags,
    required this.annotations,
    this.priority,
    this.wait,
    this.end,
    required this.depends,
    required this.uda,
  });

  factory Task({required String description}) =>
      RustLib.instance.api.crateTaskTaskNew(description: description);

  @override
  int get hashCode =>
      uuid.hashCode ^
      status.hashCode ^
      description.hashCode ^
      modified.hashCode ^
      due.hashCode ^
      project.hashCode ^
      tags.hashCode ^
      annotations.hashCode ^
      priority.hashCode ^
      wait.hashCode ^
      end.hashCode ^
      depends.hashCode ^
      uda.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Task &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          status == other.status &&
          description == other.description &&
          modified == other.modified &&
          due == other.due &&
          project == other.project &&
          tags == other.tags &&
          annotations == other.annotations &&
          priority == other.priority &&
          wait == other.wait &&
          end == other.end &&
          depends == other.depends &&
          uda == other.uda;
}

enum TaskStatus {
  pending,
  waiting,
  recurring,
  deleted,
  complete,
  ;
}
